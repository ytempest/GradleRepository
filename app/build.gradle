apply plugin: 'com.android.application'
// 一个打印配置的脚本
apply from: './print.gradle'
// 将apk.gradle引入到当前gradle脚本中
apply from: './apk.gradle'
// 学习使用git获取版本名和版本号的脚本
apply from: './vc_vn.gradle'

android {
    compileSdkVersion rootProject.compileSdkVersion
    defaultConfig {
        // 指定生成的applicationId，生成的id可以在apk文件的AndroidManifest.xml可以看到
        applicationId "com.ytempest.gradlerepository"
        // 指定生成的applicationId的后缀，这个会加到applicationId的后面
        applicationIdSuffix ".base"
        minSdkVersion rootProject.minSdkVersion
        targetSdkVersion rootProject.targetSdkVersion
        versionCode rootProject.versionCode
        versionName rootProject.versionName
        // 用于配置单元测试时使用的Runner
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }

    /*配置签名信息*/
    // 配置了签名信息后，还不能直接生成签名的apk，需要在buildTypes的类型中使用想要的签名信息
    signingConfigs {
        debug {
            storeFile file("./keyStore/gradleRepository.jks")
            storePassword "gradle123"
            keyAlias "gradle"
            keyPassword "gradle123"
        }

        release {
            // 文件位置以根目录为起点
            storeFile file("./keystore/gradleRepository.jks")
            // 密钥库密码
            storePassword "gradle123"
            // 密钥别名
            keyAlias "gradle"
            // 密钥密码
            keyPassword "gradle123"
        }
    }

    // 设置风味的维度，维度有大小区分，第一个维度最大，依次减小，最终的风味的维度=第1维度+第2维度+...+第n维度
    // 生成的BuildConfig类中的FLAVOR的值为："dimension1"+"dimension2"+"dimension3"+....
    flavorDimensions "store", "phone"
    productFlavors {
        baidu {
            dimension "store"
            applicationIdSuffix ".baidu"
        }

        xiaomi {
            dimension "phone"
            applicationId "com.ytempest.xiaomi.gradlerepository"
            applicationIdSuffix ".miui"
        }

        huawei {
            dimension "phone"
            applicationIdSuffix ".emui"
        }
    }

    /*构建类型*/
    // 即定义 gradlew assembleXXX 中 XXX 的构建，如下面的 common，可以打包 gradlew assembleCommon
    // 为了直观，所以大多使用 debug 和 release 两个命名
    buildTypes {

        common {
            // 是否生成一个可供调试的 apk，默认为false
            debuggable true
            // 是否生成一个可供调试Jni(C/C++)的 apk，默认为false
            jniDebuggable true
        }

        debug {
            // 构建类型只能配置applicationIdSuffix，不能配置applicationId
            applicationIdSuffix ".debugsuffix"
            minifyEnabled false
            debuggable true
            signingConfig signingConfigs.debug
        }

        release {
            // 配置是否启动混淆
            minifyEnabled true
            // 配置是否自动清理未使用的资源，默认为false，AS 3.0.1之后开启该配置，必须先启动混淆，否则会编译报错
            // 其实该配置依然会将资源打包到apk，只是会将图片替换成一个像素的正方形
            shrinkResources true
            // 配置了签名信息后，还不能直接生成签名的apk，需要在这里指定使用的签名类型
            signingConfig signingConfigs.release
            // 配置多个混淆文件
            // getDefaultProguardFile获取的的是 SDK目录/tools/proguard 目录下的文件，proguard-android.txt是Android SDK
            // 自带的混淆配置文件，这个是没有优化，一个是proguard-android-optimize.txt，这个是优化过的，对比请看proguard_sample文件夹
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            // zipalign是Android提供的一个整理优化apk文件的工具，它能提高系统和应用的运行效率，更快
            // 地读写apk中的资源，降低内存使用，该配置默认开启
            zipAlignEnabled true
        }
    }
}

// 配置aar包存放位置，设置存放在libs
repositories {
    flatDir { dirs 'libs' }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:26.1.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}
